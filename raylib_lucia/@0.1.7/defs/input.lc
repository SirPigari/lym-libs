private final is_key_pressed_c: &int = libload.get_fn(lib, "IsKeyPressed", ["int"], "bool")
private final is_key_pressed_repeat_c: &int = libload.get_fn(lib, "IsKeyPressedRepeat", ["int"], "bool")
private final is_key_down_c: &int = libload.get_fn(lib, "IsKeyDown", ["int"], "bool")
private final is_key_released_c: &int = libload.get_fn(lib, "IsKeyReleased", ["int"], "bool")
private final is_key_up_c: &int = libload.get_fn(lib, "IsKeyUp", ["int"], "bool")
private final get_key_pressed_c: &int = libload.get_fn(lib, "GetKeyPressed", [], "int")
private final get_char_pressed_c: &int = libload.get_fn(lib, "GetCharPressed", [], "int")
private final set_exit_key_c: &int = libload.get_fn(lib, "SetExitKey", ["int"], "void")

private final is_gamepad_available_c: &int = libload.get_fn(lib, "IsGamepadAvailable", ["int"], "bool")
private final get_gamepad_name_c: &int = libload.get_fn(lib, "GetGamepadName", ["int"], "str")
private final is_gamepad_button_pressed_c: &int = libload.get_fn(lib, "IsGamepadButtonPressed", ["int", "int"], "bool")
private final is_gamepad_button_down_c: &int = libload.get_fn(lib, "IsGamepadButtonDown", ["int", "int"], "bool")
private final is_gamepad_button_released_c: &int = libload.get_fn(lib, "IsGamepadButtonReleased", ["int", "int"], "bool")
private final is_gamepad_button_up_c: &int = libload.get_fn(lib, "IsGamepadButtonUp", ["int", "int"], "bool")
private final get_gamepad_button_pressed_c: &int = libload.get_fn(lib, "GetGamepadButtonPressed", [], "int")
private final get_gamepad_axis_count_c: &int = libload.get_fn(lib, "GetGamepadAxisCount", ["int"], "int")
private final get_gamepad_axis_movement_c: &int = libload.get_fn(lib, "GetGamepadAxisMovement", ["int", "int"], "float")
private final set_gamepad_mappings_c: &int = libload.get_fn(lib, "SetGamepadMappings", ["str"], "int")
private final set_gamepad_vibration_c: &int = libload.get_fn(lib, "SetGamepadVibration", ["int", "float", "float", "float"], "void")

private final is_mouse_button_pressed_c: &int = libload.get_fn(lib, "IsMouseButtonPressed", ["int"], "bool")
private final is_mouse_button_down_c: &int = libload.get_fn(lib, "IsMouseButtonDown", ["int"], "bool")
private final is_mouse_button_released_c: &int = libload.get_fn(lib, "IsMouseButtonReleased", ["int"], "bool")
private final is_mouse_button_up_c: &int = libload.get_fn(lib, "IsMouseButtonUp", ["int"], "bool")
private final get_mouse_x_c: &int = libload.get_fn(lib, "GetMouseX", [], "int")
private final get_mouse_y_c: &int = libload.get_fn(lib, "GetMouseY", [], "int")
private final set_mouse_position_c: &int = libload.get_fn(lib, "SetMousePosition", ["int", "int"], "void")
private final set_mouse_offset_c: &int = libload.get_fn(lib, "SetMouseOffset", ["int", "int"], "void")
private final set_mouse_scale_c: &int = libload.get_fn(lib, "SetMouseScale", ["float", "float"], "void")
private final get_mouse_wheel_move_c: &int = libload.get_fn(lib, "GetMouseWheelMove", [], "float")
private final set_mouse_cursor_c: &int = libload.get_fn(lib, "SetMouseCursor", ["int"], "void")

private final get_touch_x_c: &int = libload.get_fn(lib, "GetTouchX", [], "int")
private final get_touch_y_c: &int = libload.get_fn(lib, "GetTouchY", [], "int")
private final get_touch_point_id_c: &int = libload.get_fn(lib, "GetTouchPointId", ["int"], "int")
private final get_touch_point_count_c: &int = libload.get_fn(lib, "GetTouchPointCount", [], "int")

private final set_gestures_enabled_c: &int = libload.get_fn(lib, "SetGesturesEnabled", ["int"], "void")
private final is_gesture_detected_c: &int = libload.get_fn(lib, "IsGestureDetected", ["int"], "bool")
private final get_gesture_detected_c: &int = libload.get_fn(lib, "GetGestureDetected", [], "int")
private final get_gesture_hold_duration_c: &int = libload.get_fn(lib, "GetGestureHoldDuration", [], "float")
private final get_gesture_drag_angle_c: &int = libload.get_fn(lib, "GetGestureDragAngle", [], "float")
private final get_gesture_pinch_angle_c: &int = libload.get_fn(lib, "GetGesturePinchAngle", [], "float")

// bindings for lucia
private final get_mouse_position_c: &int = libload.get_fn(lib_lucia, "bind_GetMousePosition", [], "str")
private final get_mouse_delta_c: &int = libload.get_fn(lib_lucia, "bind_GetMouseDelta", [], "str")
private final get_mouse_wheel_move_v_c: &int = libload.get_fn(lib_lucia, "bind_GetMouseWheelMoveV", [], "str")
private final get_touch_position_c: &int = libload.get_fn(lib_lucia, "bind_GetTouchPosition", ["int"], "str")
private final get_gesture_pinch_vector_c: &int = libload.get_fn(lib_lucia, "bind_GetGesturePinchVector", [], "str")
private final get_gesture_drag_vector_c: &int = libload.get_fn(lib_lucia, "bind_GetGestureDragVector", [], "str")

// using 'scope (*)' to group related functions and constants
// doesnt do anything just for folding in editor
// if scope deosnt have a name provided and has (*) it will be ignored by lucia and just runned in the local scope

// Key constants
scope (*):
    public final KEY_NULL: int            = 0        // Key: NULL, used for no key pressed
    // Alphanumeric keys
    public final KEY_APOSTROPHE: int      = 39       // Key: '
    public final KEY_COMMA: int           = 44       // Key: ,
    public final KEY_MINUS: int           = 45       // Key: -
    public final KEY_PERIOD: int          = 46       // Key: .
    public final KEY_SLASH: int           = 47       // Key: /
    public final KEY_ZERO: int            = 48       // Key: 0
    public final KEY_ONE: int             = 49       // Key: 1
    public final KEY_TWO: int             = 50       // Key: 2
    public final KEY_THREE: int           = 51       // Key: 3
    public final KEY_FOUR: int            = 52       // Key: 4
    public final KEY_FIVE: int            = 53       // Key: 5
    public final KEY_SIX: int             = 54       // Key: 6
    public final KEY_SEVEN: int           = 55       // Key: 7
    public final KEY_EIGHT: int           = 56       // Key: 8
    public final KEY_NINE: int            = 57       // Key: 9
    public final KEY_SEMICOLON: int       = 59       // Key: ;
    public final KEY_EQUAL: int           = 61       // Key: =
    public final KEY_A: int               = 65       // Key: A | a
    public final KEY_B: int               = 66       // Key: B | b
    public final KEY_C: int               = 67       // Key: C | c
    public final KEY_D: int               = 68       // Key: D | d
    public final KEY_E: int               = 69       // Key: E | e
    public final KEY_F: int               = 70       // Key: F | f
    public final KEY_G: int               = 71       // Key: G | g
    public final KEY_H: int               = 72       // Key: H | h
    public final KEY_I: int               = 73       // Key: I | i
    public final KEY_J: int               = 74       // Key: J | j
    public final KEY_K: int               = 75       // Key: K | k
    public final KEY_L: int               = 76       // Key: L | l
    public final KEY_M: int               = 77       // Key: M | m
    public final KEY_N: int               = 78       // Key: N | n
    public final KEY_O: int               = 79       // Key: O | o
    public final KEY_P: int               = 80       // Key: P | p
    public final KEY_Q: int               = 81       // Key: Q | q
    public final KEY_R: int               = 82       // Key: R | r
    public final KEY_S: int               = 83       // Key: S | s
    public final KEY_T: int               = 84       // Key: T | t
    public final KEY_U: int               = 85       // Key: U | u
    public final KEY_V: int               = 86       // Key: V | v
    public final KEY_W: int               = 87       // Key: W | w
    public final KEY_X: int               = 88       // Key: X | x
    public final KEY_Y: int               = 89       // Key: Y | y
    public final KEY_Z: int               = 90       // Key: Z | z
    public final KEY_LEFT_BRACKET: int    = 91       // Key: [
    public final KEY_BACKSLASH: int       = 92       // Key: '\'
    public final KEY_RIGHT_BRACKET: int   = 93       // Key: ]
    public final KEY_GRAVE: int           = 96       // Key: `
    // Function keys
    public final KEY_SPACE: int           = 32       // Key: Space
    public final KEY_ESCAPE: int          = 256      // Key: Esc
    public final KEY_ENTER: int           = 257      // Key: Enter
    public final KEY_TAB: int             = 258      // Key: Tab
    public final KEY_BACKSPACE: int       = 259      // Key: Backspace
    public final KEY_INSERT: int          = 260      // Key: Ins
    public final KEY_DELETE: int          = 261      // Key: Del
    public final KEY_RIGHT: int           = 262      // Key: Cursor right
    public final KEY_LEFT: int            = 263      // Key: Cursor left
    public final KEY_DOWN: int            = 264      // Key: Cursor down
    public final KEY_UP: int              = 265      // Key: Cursor up
    public final KEY_PAGE_UP: int         = 266      // Key: Page up
    public final KEY_PAGE_DOWN: int       = 267      // Key: Page down
    public final KEY_HOME: int            = 268      // Key: Home
    public final KEY_END: int             = 269      // Key: End
    public final KEY_CAPS_LOCK: int       = 280      // Key: Caps lock
    public final KEY_SCROLL_LOCK: int     = 281      // Key: Scroll down
    public final KEY_NUM_LOCK: int        = 282      // Key: Num lock
    public final KEY_PRINT_SCREEN: int    = 283      // Key: Print screen
    public final KEY_PAUSE: int           = 284      // Key: Pause
    public final KEY_F1: int              = 290      // Key: F1
    public final KEY_F2: int              = 291      // Key: F2
    public final KEY_F3: int              = 292      // Key: F3
    public final KEY_F4: int              = 293      // Key: F4
    public final KEY_F5: int              = 294      // Key: F5
    public final KEY_F6: int              = 295      // Key: F6
    public final KEY_F7: int              = 296      // Key: F7
    public final KEY_F8: int              = 297      // Key: F8
    public final KEY_F9: int              = 298      // Key: F9
    public final KEY_F10: int             = 299      // Key: F10
    public final KEY_F11: int             = 300      // Key: F11
    public final KEY_F12: int             = 301      // Key: F12
    public final KEY_LEFT_SHIFT: int      = 340      // Key: Shift left
    public final KEY_LEFT_CONTROL: int    = 341      // Key: Control left
    public final KEY_LEFT_ALT: int        = 342      // Key: Alt left
    public final KEY_LEFT_SUPER: int      = 343      // Key: Super left
    public final KEY_RIGHT_SHIFT: int     = 344      // Key: Shift right
    public final KEY_RIGHT_CONTROL: int   = 345      // Key: Control right
    public final KEY_RIGHT_ALT: int       = 346      // Key: Alt right
    public final KEY_RIGHT_SUPER: int     = 347      // Key: Super right
    public final KEY_KB_MENU: int         = 348      // Key: KB menu
    // Keypad keys
    public final KEY_KP_0: int            = 320      // Key: Keypad 0
    public final KEY_KP_1: int            = 321      // Key: Keypad 1
    public final KEY_KP_2: int            = 322      // Key: Keypad 2
    public final KEY_KP_3: int            = 323      // Key: Keypad 3
    public final KEY_KP_4: int            = 324      // Key: Keypad 4
    public final KEY_KP_5: int            = 325      // Key: Keypad 5
    public final KEY_KP_6: int            = 326      // Key: Keypad 6
    public final KEY_KP_7: int            = 327      // Key: Keypad 7
    public final KEY_KP_8: int            = 328      // Key: Keypad 8
    public final KEY_KP_9: int            = 329      // Key: Keypad 9
    public final KEY_KP_DECIMAL: int      = 330      // Key: Keypad .
    public final KEY_KP_DIVIDE: int       = 331      // Key: Keypad /
    public final KEY_KP_MULTIPLY: int     = 332      // Key: Keypad *
    public final KEY_KP_SUBTRACT: int     = 333      // Key: Keypad -
    public final KEY_KP_ADD: int          = 334      // Key: Keypad +
    public final KEY_KP_ENTER: int        = 335      // Key: Keypad Enter
    public final KEY_KP_EQUAL: int        = 336      // Key: Keypad =
    // Android key buttons
    public final KEY_BACK: int            = 4        // Key: Android back button
    public final KEY_MENU: int            = 5        // Key: Android menu button
    public final KEY_VOLUME_UP: int       = 24       // Key: Android volume up button
    public final KEY_VOLUME_DOWN: int     = 25       // Key: Android volume down button

    // Mouse buttons
    public final MOUSE_BUTTON_LEFT: int    = 0       // Mouse button left
    public final MOUSE_BUTTON_RIGHT: int   = 1       // Mouse button right
    public final MOUSE_BUTTON_MIDDLE: int  = 2       // Mouse button middle (pressed wheel)
    public final MOUSE_BUTTON_SIDE: int    = 3       // Mouse button side (advanced mouse device)
    public final MOUSE_BUTTON_EXTRA: int   = 4       // Mouse button extra (advanced mouse device)
    public final MOUSE_BUTTON_FORWARD: int = 5       // Mouse button forward (advanced mouse device)
    public final MOUSE_BUTTON_BACK: int    = 6       // Mouse button back (advanced mouse device)

    // Add backwards compatibility support for deprecated names
    public final MOUSE_LEFT_BUTTON: int    = MOUSE_BUTTON_LEFT
    public final MOUSE_RIGHT_BUTTON: int   = MOUSE_BUTTON_RIGHT
    public final MOUSE_MIDDLE_BUTTON: int  = MOUSE_BUTTON_MIDDLE

    // Mouse cursor
    public final MOUSE_CURSOR_DEFAULT: int              = 0     // Default pointer shape
    public final MOUSE_CURSOR_ARROW: int                = 1     // Arrow shape
    public final MOUSE_CURSOR_IBEAM: int                = 2     // Text writing cursor shape
    public final MOUSE_CURSOR_CROSSHAIR: int            = 3     // Cross shape
    public final MOUSE_CURSOR_POINTING_HAND: int        = 4     // Pointing hand cursor
    public final MOUSE_CURSOR_RESIZE_EW: int            = 5     // Horizontal resize/move arrow shape
    public final MOUSE_CURSOR_RESIZE_NS: int            = 6     // Vertical resize/move arrow shape
    public final MOUSE_CURSOR_RESIZE_NWSE: int          = 7     // Top-left to bottom-right diagonal resize/move arrow shape
    public final MOUSE_CURSOR_RESIZE_NESW: int          = 8     // The top-right to bottom-left diagonal resize/move arrow shape
    public final MOUSE_CURSOR_RESIZE_ALL: int           = 9     // The omnidirectional resize/move cursor shape
    public final MOUSE_CURSOR_NOT_ALLOWED: int          = 10     // The operation-not-allowed shape

    // Gamepad buttons
    public final GAMEPAD_BUTTON_UNKNOWN: int            = 0       // Unknown button, just for error checking
    public final GAMEPAD_BUTTON_LEFT_FACE_UP: int       = 1      // Gamepad left DPAD up button
    public final GAMEPAD_BUTTON_LEFT_FACE_RIGHT: int    = 2      // Gamepad left DPAD right button
    public final GAMEPAD_BUTTON_LEFT_FACE_DOWN: int     = 3      // Gamepad left DPAD down button
    public final GAMEPAD_BUTTON_LEFT_FACE_LEFT: int     = 4      // Gamepad left DPAD left button
    public final GAMEPAD_BUTTON_RIGHT_FACE_UP: int      = 5      // Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
    public final GAMEPAD_BUTTON_RIGHT_FACE_RIGHT: int   = 6      // Gamepad right button right (i.e. PS3: Circle, Xbox: B)
    public final GAMEPAD_BUTTON_RIGHT_FACE_DOWN: int    = 7      // Gamepad right button down (i.e. PS3: Cross, Xbox: A)
    public final GAMEPAD_BUTTON_RIGHT_FACE_LEFT: int    = 8      // Gamepad right button left (i.e. PS3: Square, Xbox: X)
    public final GAMEPAD_BUTTON_LEFT_TRIGGER_1: int     = 9      // Gamepad top/back trigger left (first), it could be a trailing button
    public final GAMEPAD_BUTTON_LEFT_TRIGGER_2: int     = 10     // Gamepad top/back trigger left (second), it could be a trailing button
    public final GAMEPAD_BUTTON_RIGHT_TRIGGER_1: int    = 11     // Gamepad top/back trigger right (first), it could be a trailing button
    public final GAMEPAD_BUTTON_RIGHT_TRIGGER_2: int    = 12     // Gamepad top/back trigger right (second), it could be a trailing button
    public final GAMEPAD_BUTTON_MIDDLE_LEFT: int        = 13     // Gamepad center buttons, left one (i.e. PS3: Select)
    public final GAMEPAD_BUTTON_MIDDLE: int             = 14     // Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
    public final GAMEPAD_BUTTON_MIDDLE_RIGHT: int       = 15     // Gamepad center buttons, right one (i.e. PS3: Start)
    public final GAMEPAD_BUTTON_LEFT_THUMB: int         = 16     // Gamepad joystick pressed button left
    public final GAMEPAD_BUTTON_RIGHT_THUMB: int        = 17     // Gamepad joystick pressed button right

    // Gamepad axis
    public final GAMEPAD_AXIS_LEFT_X: int               = 0      // Gamepad left stick X axis
    public final GAMEPAD_AXIS_LEFT_Y: int               = 1      // Gamepad left stick Y axis
    public final GAMEPAD_AXIS_RIGHT_X: int              = 2      // Gamepad right stick X axis
    public final GAMEPAD_AXIS_RIGHT_Y: int              = 3      // Gamepad right stick Y axis
    public final GAMEPAD_AXIS_LEFT_TRIGGER: int         = 4      // Gamepad back trigger left, pressure level: [1..-1]
    public final GAMEPAD_AXIS_RIGHT_TRIGGER: int        = 5      // Gamepad back trigger right, pressure level: [1..-1]
end

// Keyboard input functions
scope (*):
    public final fun is_key_pressed(key: int) -> bool:
        /// Returns true if the specified key is currently being pressed (only once).
        ///     @param key: int - The key to check (use KEY_* constants).
        ///     @return: bool - true if the key is pressed, false otherwise.
        if (is_key_pressed_c == null):
            throw "Function 'is_key_pressed' not found in the loaded library." from "FunctionNotFoundError"
        end
        return libload.call_fn(is_key_pressed_c, [key]) as bool
    end

    public final fun is_key_pressed_repeat(key: int) -> bool:
        /// Returns true if the specified key is being pressed (with repeat).
        ///     @param key: int - The key to check (use KEY_* constants).
        ///     @return: bool - true if the key is pressed, false otherwise.
        if (is_key_pressed_repeat_c == null):
            throw "Function 'is_key_pressed_repeat' not found in the loaded library." from "FunctionNotFoundError"
        end
        return libload.call_fn(is_key_pressed_repeat_c, [key]) as bool
    end

    public final fun is_key_down(key: int) -> bool:
        /// Returns true if the specified key is being held down.
        ///     @param key: int - The key to check (use KEY_* constants).
        ///     @return: bool - true if the key is down, false otherwise.
        if (is_key_down_c == null):
            throw "Function 'is_key_down' not found in the loaded library." from "FunctionNotFoundError"
        end
        return libload.call_fn(is_key_down_c, [key]) as bool
    end

    public final fun is_key_released(key: int) -> bool:
        /// Returns true if the specified key has been released.
        ///     @param key: int - The key to check (use KEY_* constants).
        ///     @return: bool - true if the key is released, false otherwise.
        if (is_key_released_c == null):
            throw "Function 'is_key_released' not found in the loaded library." from "FunctionNotFoundError"
        end
        return libload.call_fn(is_key_released_c, [key]) as bool
    end

    public final fun is_key_up(key: int) -> bool:
        /// Returns true if the specified key is not being pressed.
        ///     @param key: int - The key to check (use KEY_* constants).
        ///     @return: bool - true if the key is up, false otherwise.
        if (is_key_up_c == null):
            throw "Function 'is_key_up' not found in the loaded library." from "FunctionNotFoundError"
        end
        return libload.call_fn(is_key_up_c, [key]) as bool
    end

    public final fun get_key_pressed() -> int:
        /// Returns the last key pressed (keycode), call it multiple times for keys queued.
        ///     @return: int - The last key pressed (keycode).
        if (get_key_pressed_c == null):
            throw "Function 'get_key_pressed' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: int = libload.call_fn(get_key_pressed_c, [])
        return result
    end

    public final fun get_char_pressed() -> int:
        /// Returns the last character pressed (unicode), call it multiple times for characters queued.
        ///     @return: int - The last character pressed (unicode).
        if (get_char_pressed_c == null):
            throw "Function 'get_char_pressed' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: int = libload.call_fn(get_char_pressed_c, [])
        return result
    end

    public final fun set_exit_key(key: int = KEY_ESCAPE) -> void:
        /// Sets a custom key to exit the program (default is ESCAPE).
        ///     @param key: int - The key to set as exit key (use KEY_* constants).
        ///     @return: void - No return value.
        if (set_exit_key_c == null):
            throw "Function 'set_exit_key' not found in the loaded library." from "FunctionNotFoundError"
        end
        libload.call_fn(set_exit_key_c, [key])
        return null
    end
end

// Gamepad input functions
scope (*):
    public final fun is_gamepad_available(gamepad: int) -> bool:
        /// Returns true if the specified gamepad is available.
        ///     @param gamepad: int - The gamepad to check (0 to MAX_GAMEPADS - 1).
        ///     @return: bool - true if the gamepad is available, false otherwise.
        if (is_gamepad_available_c == null):
            throw "Function 'is_gamepad_available' not found in the loaded library." from "FunctionNotFoundError"
        end
        return libload.call_fn(is_gamepad_available_c, [gamepad]) as bool
    end

    public final fun get_gamepad_name(gamepad: int) -> str:
        /// Returns the internal name of the specified gamepad.
        ///     @param gamepad: int - The gamepad to get the name (0 to MAX_GAMEPADS - 1).
        ///     @return: str - The internal name of the gamepad.
        if (get_gamepad_name_c == null):
            throw "Function 'get_gamepad_name' not found in the loaded library." from "FunctionNotFoundError"
        end
        result_str_ptr: &int = libload.call_fn(get_gamepad_name_c, [gamepad])
        return libload.parse_str_ptr(result_str_ptr) as str
    end

    public final fun is_gamepad_button_pressed(gamepad: int, button: int) -> bool:
        /// Returns true if the specified gamepad button is being pressed (only once).
        ///     @param gamepad: int - The gamepad to check (0 to MAX_GAMEPADS - 1).
        ///     @param button: int - The button to check (use GAMEPAD_BUTTON_* constants).
        ///     @return: bool - true if the button is pressed, false otherwise.
        if (is_gamepad_button_pressed_c == null):
            throw "Function 'is_gamepad_button_pressed' not found in the loaded library." from "FunctionNotFoundError"
        end
        return libload.call_fn(is_gamepad_button_pressed_c, [gamepad, button]) as bool
    end

    public final fun is_gamepad_button_down(gamepad: int, button: int) -> bool:
        /// Returns true if the specified gamepad button is being held down.
        ///     @param gamepad: int - The gamepad to check (0 to MAX_GAMEPADS - 1).
        ///     @param button: int - The button to check (use GAMEPAD_BUTTON_* constants).
        ///     @return: bool - true if the button is down, false otherwise.
        if (is_gamepad_button_down_c == null):
            throw "Function 'is_gamepad_button_down' not found in the loaded library." from "FunctionNotFoundError"
        end
        return libload.call_fn(is_gamepad_button_down_c, [gamepad, button]) as bool
    end

    public final fun is_gamepad_button_released(gamepad: int, button: int) -> bool:
        /// Returns true if the specified gamepad button has been released.
        ///     @param gamepad: int - The gamepad to check (0 to MAX_GAMEPADS - 1).
        ///     @param button: int - The button to check (use GAMEPAD_BUTTON_* constants).
        ///     @return: bool - true if the button is released, false otherwise.
        if (is_gamepad_button_released_c == null):
            throw "Function 'is_gamepad_button_released' not found in the loaded library." from "FunctionNotFoundError"
        end
        return libload.call_fn(is_gamepad_button_released_c, [gamepad, button]) as bool
    end

    public final fun is_gamepad_button_up(gamepad: int, button: int) -> bool:
        /// Returns true if the specified gamepad button is not being pressed.
        ///     @param gamepad: int - The gamepad to check (0 to MAX_GAMEPADS - 1).
        ///     @param button: int - The button to check (use GAMEPAD_BUTTON_* constants).
        ///     @return: bool - true if the button is up, false otherwise.
        if (is_gamepad_button_up_c == null):
            throw "Function 'is_gamepad_button_up' not found in the loaded library." from "FunctionNotFoundError"
        end
        return libload.call_fn(is_gamepad_button_up_c, [gamepad, button]) as bool
    end

    public final fun get_gamepad_button_pressed() -> int:
        /// Returns the last gamepad button pressed (button code), call it multiple times for buttons queued.
        ///     @return: int - The last gamepad button pressed (button code).
        if (get_gamepad_button_pressed_c == null):
            throw "Function 'get_gamepad_button_pressed' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: int = libload.call_fn(get_gamepad_button_pressed_c, [])
        return result
    end

    public final fun get_gamepad_axis_count(gamepad: int) -> int:
        /// Returns the number of axes for a gamepad.
        ///     @param gamepad: int - The gamepad to check (0 to MAX_GAMEPADS - 1).
        ///     @return: int - The number of axes for the gamepad.
        if (get_gamepad_axis_count_c == null):
            throw "Function 'get_gamepad_axis_count' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: int = libload.call_fn(get_gamepad_axis_count_c, [gamepad])
        return result
    end

    public final fun get_gamepad_axis_movement(gamepad: int, axis: int) -> float:
        /// Returns the movement value for a gamepad axis.
        ///     @param gamepad: int - The gamepad to check (0 to MAX_GAMEPADS - 1).
        ///     @param axis: int - The axis to check (use GAMEPAD_AXIS_* constants).
        ///     @return: float - The movement value for the axis.
        if (get_gamepad_axis_movement_c == null):
            throw "Function 'get_gamepad_axis_movement' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: float = libload.call_fn(get_gamepad_axis_movement_c, [gamepad, axis]) as float
        return result
    end

    public final fun set_gamepad_mappings(mappings: str) -> int:
        /// Sets internal gamepad mappings (SDL_GameControllerDB).
        ///     @param mappings: str - The string defining the gamepad mappings in SDL format.
        ///     @return: int - The number of gamepad mappings added.
        if (set_gamepad_mappings_c == null):
            throw "Function 'set_gamepad_mappings' not found in the loaded library." from "FunctionNotFoundError"
        end
        _mappings: &int = libload.create_str_ptr(mappings)
        result: int = libload.call_fn(set_gamepad_mappings_c, [_mappings])
        return result
    end

    public final fun set_gamepad_vibration(gamepad: int, left_motor: float, right_motor: float, duration: float) -> void:
        /// Activates internal gamepad vibration motors.
        ///     @param gamepad: int - The gamepad to vibrate (0 to MAX_GAMEPADS - 1).
        ///     @param left_motor: float - The intensity of the left motor (0.0 to 1.0).
        ///     @param right_motor: float - The intensity of the right motor (0.0 to 1.0).
        ///     @param duration: float - The duration of the vibration in seconds.
        ///     @return: void - No return value.
        if (set_gamepad_vibration_c == null):
            throw "Function 'set_gamepad_vibration' not found in the loaded library." from "FunctionNotFoundError"
        end
        libload.call_fn(set_gamepad_vibration_c, [gamepad, left_motor, right_motor, duration])
        return null
    end
end

// Mouse input functions
scope (*):
    public final fun is_mouse_button_pressed(button: int) -> bool:
        /// Returns true if the specified mouse button is being pressed (only once).
        ///     @param button: int - The mouse button to check (use MOUSE_BUTTON_* constants).
        ///     @return: bool - true if the button is pressed, false otherwise.
        if (is_mouse_button_pressed_c == null):
            throw "Function 'is_mouse_button_pressed' not found in the loaded library." from "FunctionNotFoundError"
        end
        return libload.call_fn(is_mouse_button_pressed_c, [button]) as bool
    end

    public final fun is_mouse_button_down(button: int) -> bool:
        /// Returns true if the specified mouse button is being held down.
        ///     @param button: int - The mouse button to check (use MOUSE_BUTTON_* constants).
        ///     @return: bool - true if the button is down, false otherwise.
        if (is_mouse_button_down_c == null):
            throw "Function 'is_mouse_button_down' not found in the loaded library." from "FunctionNotFoundError"
        end
        return libload.call_fn(is_mouse_button_down_c, [button]) as bool
    end

    public final fun is_mouse_button_released(button: int) -> bool:
        /// Returns true if the specified mouse button has been released.
        ///     @param button: int - The mouse button to check (use MOUSE_BUTTON_* constants).
        ///     @return: bool - true if the button is released, false otherwise.
        if (is_mouse_button_released_c == null):
            throw "Function 'is_mouse_button_released' not found in the loaded library." from "FunctionNotFoundError"
        end
        return libload.call_fn(is_mouse_button_released_c, [button]) as bool
    end

    public final fun is_mouse_button_up(button: int) -> bool:
        /// Returns true if the specified mouse button is not being pressed.
        ///     @param button: int - The mouse button to check (use MOUSE_BUTTON_* constants).
        ///     @return: bool - true if the button is up, false otherwise.
        if (is_mouse_button_up_c == null):
            throw "Function 'is_mouse_button_up' not found in the loaded library." from "FunctionNotFoundError"
        end
        return libload.call_fn(is_mouse_button_up_c, [button]) as bool
    end

    public final fun get_mouse_x() -> int:
        /// Returns the X position of the mouse.
        ///     @return: int - The X position of the mouse.
        if (get_mouse_x_c == null):
            throw "Function 'get_mouse_x' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: int = libload.call_fn(get_mouse_x_c, [])
        return result
    end

    public final fun get_mouse_y() -> int:
        /// Returns the Y position of the mouse.
        ///     @return: int - The Y position of the mouse.
        if (get_mouse_y_c == null):
            throw "Function 'get_mouse_y' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: int = libload.call_fn(get_mouse_y_c, [])
        return result
    end

    public final fun set_mouse_position(x: int, y: int) -> void:
        /// Sets the position of the mouse.
        ///     @param x: int - The X position to set the mouse to.
        ///     @param y: int - The Y position to set the mouse to.
        ///     @return: void - No return value.
        if (set_mouse_position_c == null):
            throw "Function 'set_mouse_position' not found in the loaded library." from "FunctionNotFoundError"
        end
        libload.call_fn(set_mouse_position_c, [x, y])
        return null
    end

    public final fun set_mouse_offset(offset_x: int, offset_y: int) -> void:
        /// Sets the mouse offset.
        ///     @param offset_x: int - The X offset to set.
        ///     @param offset_y: int - The Y offset to set.
        ///     @return: void - No return value.
        if (set_mouse_offset_c == null):
            throw "Function 'set_mouse_offset' not found in the loaded library." from "FunctionNotFoundError"
        end
        libload.call_fn(set_mouse_offset_c, [offset_x, offset_y])
        return null
    end

    public final fun set_mouse_scale(scale_x: float, scale_y: float) -> void:
        /// Sets the mouse scaling.
        ///     @param scale_x: float - The X scale to set.
        ///     @param scale_y: float - The Y scale to set.
        ///     @return: void - No return value.
        if (set_mouse_scale_c == null):
            throw "Function 'set_mouse_scale' not found in the loaded library." from "FunctionNotFoundError"
        end
        libload.call_fn(set_mouse_scale_c, [scale_x, scale_y])
        return null
    end

    public final fun get_mouse_wheel_move() -> float:
        /// Returns the mouse wheel movement Y.
        ///     @return: float - The mouse wheel movement Y.
        if (get_mouse_wheel_move_c == null):
            throw "Function 'get_mouse_wheel_move' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: float = libload.call_fn(get_mouse_wheel_move_c, []) as float
        return result
    end

    public final fun set_mouse_cursor(cursor: int) -> void:
        /// Sets the mouse cursor.
        ///     @param cursor: int - The cursor to set (use MOUSE_CURSOR_* constants).
        ///     @return: void - No return value.
        if (set_mouse_cursor_c == null):
            throw "Function 'set_mouse_cursor' not found in the loaded library." from "FunctionNotFoundError"
        end
        libload.call_fn(set_mouse_cursor_c, [cursor])
        return null
    end
end

// Touch input functions
scope (*):
    public final fun get_touch_x(index: int) -> int:
        /// Returns the X position of the touch point at index.
        ///     @param index: int - The touch point index (0 to MAX_TOUCH_POINTS - 1).
        ///     @return: int - The X position of the touch point.
        if (get_touch_x_c == null):
            throw "Function 'get_touch_x' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: int = libload.call_fn(get_touch_x_c, [index])
        return result
    end

    public final fun get_touch_y(index: int) -> int:
        /// Returns the Y position of the touch point at index.
        ///     @param index: int - The touch point index (0 to MAX_TOUCH_POINTS - 1).
        ///     @return: int - The Y position of the touch point.
        if (get_touch_y_c == null):
            throw "Function 'get_touch_y' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: int = libload.call_fn(get_touch_y_c, [index])
        return result
    end

    public final fun get_touch_point_id(index: int) -> int:
        /// Returns the touch point identifier for the touch point at index.
        ///     @param index: int - The touch point index (0 to MAX_TOUCH_POINTS - 1).
        ///     @return: int - The touch point identifier.
        if (get_touch_point_id_c == null):
            throw "Function 'get_touch_point_id' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: int = libload.call_fn(get_touch_point_id_c, [index])
        return result
    end

    public final fun get_touch_point_count() -> int:
        /// Returns the number of touch points.
        ///     @return: int - The number of touch points.
        if (get_touch_point_count_c == null):
            throw "Function 'get_touch_point_count' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: int = libload.call_fn(get_touch_point_count_c, [])
        return result
    end
end

// Gestures input functions
scope (*):
    public final fun set_gestures_enabled() -> bool:
        /// Enables/disables gestures detection using touch points.
        ///     @return: bool - true if gestures are enabled, false otherwise.
        if (set_gestures_enabled_c == null):
            throw "Function 'set_gestures_enabled' not found in the loaded library." from "FunctionNotFoundError"
        end
        return libload.call_fn(set_gestures_enabled_c, []) as bool
    end

    public final fun is_gesture_detected(gesture: int) -> bool:
        /// Returns true if a gesture have been detected.
        ///     @param gesture: int - The gesture to check (use GESTURE_* constants).
        ///     @return: bool - true if the gesture is detected, false otherwise.
        if (is_gesture_detected_c == null):
            throw "Function 'is_gesture_detected' not found in the loaded library." from "FunctionNotFoundError"
        end
        return libload.call_fn(is_gesture_detected_c, [gesture]) as bool
    end

    public final fun get_gesture_count() -> int:
        /// Returns the number of touch points available in the current gesture.
        ///     @return: int - The number of touch points in the current gesture.
        if (get_gesture_count_c == null):
            throw "Function 'get_gesture_count' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: int = libload.call_fn(get_gesture_count_c, [])
        return result
    end

    public final fun get_gesture_hold_duration() -> float:
        /// Returns the gesture hold time in milliseconds.
        ///     @return: float - The gesture hold time in milliseconds.
        if (get_gesture_hold_duration_c == null):
            throw "Function 'get_gesture_hold_duration' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: float = libload.call_fn(get_gesture_hold_duration_c, []) as float
        return result
    end

    public final fun get_gesture_drag_angle() -> float:
        /// Returns the gesture drag angle in radians.
        ///     @return: float - The gesture drag angle in radians.
        if (get_gesture_drag_angle_c == null):
            throw "Function 'get_gesture_drag_angle' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: float = libload.call_fn(get_gesture_drag_angle_c, []) as float
        return result
    end

    public final fun get_gesture_pinch_angle() -> float:
        /// Returns the gesture pinch angle in radians.
        ///     @return: float - The gesture pinch angle in radians.
        if (get_gesture_pinch_angle_c == null):
            throw "Function 'get_gesture_pinch_angle' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: float = libload.call_fn(get_gesture_pinch_angle_c, []) as float
        return result
    end
end

// bindings for lucia
scope (*):
    public final fun get_mouse_position() -> tuple[int, int]:
        /// Returns the (x, y) position of the mouse.
        ///     @return: tuple[int, int] - The (x, y) position of the mouse.
        if (get_mouse_position_c == null):
            throw "Function 'get_mouse_position' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: str = libload.parse_str_ptr(libload.call_fn(get_mouse_position_c, []))
        pos: tuple[int, int] = result.split("|").map((v) => v.to_int()).collect()
        return pos
    end

    public final fun get_mouse_delta() -> tuple[int, int]:
        /// Returns the (x, y) delta movement of the mouse.
        ///     @return: tuple[int, int] - The (x, y) delta movement of the mouse.
        if (get_mouse_delta_c == null):
            throw "Function 'get_mouse_delta' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: str = libload.parse_str_ptr(libload.call_fn(get_mouse_delta_c, []))
        delta: tuple[int, int] = result.split("|").map((v) => v.to_int()).collect()
        return delta
    end

    public final fun get_mouse_wheel_move_v() -> tuple[float, float]:
        /// Returns the (x, y) mouse wheel movement.
        ///     @return: tuple[float, float] - The (x, y) mouse wheel movement.
        if (get_mouse_wheel_move_v_c == null):
            throw "Function 'get_mouse_wheel_move_v' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: str = libload.parse_str_ptr(libload.call_fn(get_mouse_wheel_move_v_c, []))
        wheel: tuple[float, float] = result.split("|").map((v) => v.to_float()).collect()
        return wheel
    end

    public final fun get_touch_position(index: int) -> tuple[int, int]:
        /// Returns the (x, y) position of the touch point at index.
        ///     @param index: int - The touch point index (0 to MAX_TOUCH_POINTS - 1).
        ///     @return: tuple[int, int] - The (x, y) position of the touch point.
        if (get_touch_position_c == null):
            throw "Function 'get_touch_position' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: str = libload.parse_str_ptr(libload.call_fn(get_touch_position_c, [index]))
        pos: tuple[int, int] = result.split("|").map((v) => v.to_int()).collect()
        return pos
    end

    public final fun get_gesture_pinch_vector() -> tuple[float, float]:
        /// Returns the (x, y) pinch vector.
        ///     @return: tuple[float, float] - The (x, y) pinch vector.
        if (get_gesture_pinch_vector_c == null):
            throw "Function 'get_gesture_pinch_vector' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: str = libload.parse_str_ptr(libload.call_fn(get_gesture_pinch_vector_c, []))
        vec: tuple[float, float] = result.split("|").map((v) => v.to_float()).collect()
        return vec
    end

    public final fun get_gesture_drag_vector() -> tuple[float, float]:
        /// Returns the (x, y) drag vector.
        ///     @return: tuple[float, float] - The (x, y) drag vector.
        if (get_gesture_drag_vector_c == null):
            throw "Function 'get_gesture_drag_vector' not found in the loaded library." from "FunctionNotFoundError"
        end
        result: str = libload.parse_str_ptr(libload.call_fn(get_gesture_drag_vector_c, []))
        vec: tuple[float, float] = result.split("|").map((v) => v.to_float()).collect()
        return vec
    end
end

// Function aliases
scope (*):
    // Keyboard input functions
    public final IsKeyPressed: function = is_key_pressed
    public final IsKeyPressedRepeat: function = is_key_pressed_repeat
    public final IsKeyDown: function = is_key_down
    public final IsKeyReleased: function = is_key_released
    public final IsKeyUp: function = is_key_up
    public final GetKeyPressed: function = get_key_pressed
    public final GetCharPressed: function = get_char_pressed
    public final SetExitKey: function = set_exit_key

    // Gamepad input functions
    public final IsGamepadAvailable: function = is_gamepad_available
    public final GetGamepadName: function = get_gamepad_name
    public final IsGamepadButtonPressed: function = is_gamepad_button_pressed
    public final IsGamepadButtonDown: function = is_gamepad_button_down
    public final IsGamepadButtonReleased: function = is_gamepad_button_released
    public final IsGamepadButtonUp: function = is_gamepad_button_up
    public final GetGamepadButtonPressed: function = get_gamepad_button_pressed
    public final GetGamepadAxisCount: function = get_gamepad_axis_count
    public final GetGamepadAxisMovement: function = get_gamepad_axis_movement
    public final SetGamepadMappings: function = set_gamepad_mappings
    public final SetGamepadVibration: function = set_gamepad_vibration

    // Mouse input functions
    public final IsMouseButtonPressed: function = is_mouse_button_pressed
    public final IsMouseButtonDown: function = is_mouse_button_down
    public final IsMouseButtonReleased: function = is_mouse_button_released
    public final IsMouseButtonUp: function = is_mouse_button_up
    public final GetMouseX: function = get_mouse_x
    public final GetMouseY: function = get_mouse_y
    public final SetMousePosition: function = set_mouse_position
    public final SetMouseOffset: function = set_mouse_offset
    public final SetMouseScale: function = set_mouse_scale
    public final GetMouseWheelMove: function = get_mouse_wheel_move
    public final SetMouseCursor: function = set_mouse_cursor
    public final GetMousePosition: function = get_mouse_position
    public final GetMouseDelta: function = get_mouse_delta
    public final GetMouseWheelMoveV: function = get_mouse_wheel_move_v
    
    // Touch input functions
    public final GetTouchX: function = get_touch_x
    public final GetTouchY: function = get_touch_y
    public final GetTouchPointId: function = get_touch_point_id
    public final GetTouchPointCount: function = get_touch_point_count
    public final GetTouchPosition: function = get_touch_position

    // Gestures input functions
    public final SetGesturesEnabled: function = set_gestures_enabled
    public final IsGestureDetected: function = is_gesture_detected
    public final GetGestureCount: function = get_gesture_count
    public final GetGestureHoldDuration: function = get_gesture_hold_duration
    public final GetGestureDragAngle: function = get_gesture_drag_angle
    public final GetGesturePinchAngle: function = get_gesture_pinch_angle
    public final GetGesturePinchVector: function = get_gesture_pinch_vector
    public final GetGestureDragVector: function = get_gesture_drag_vector
end
